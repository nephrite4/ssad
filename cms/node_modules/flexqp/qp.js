var mysql = require('mysql');
var async = require('async');
var moment = require('moment');
function Processor() {
};


Processor.prototype.db = function (dbConfig) {
    dbConfig = dbConfig || {};
    let db = {
        host: dbConfig.host || this.host,
        user: dbConfig.user || this.user,
        password: dbConfig.password || this.password,
    }
    if (dbConfig.database || this.database) {
        db.database = dbConfig.database || this.database
    }
    var con = mysql.createConnection(db);
    con.config.queryFormat = function (query, values) {
        if (!values) return query;

        if (Array.isArray(values)) {
            let offset = 0;

            return query.replace(
                /(\?{1,2})/g,
                function (text, match) {
                    offset++;

                    if (offset > values.length) return text;

                    if (match.length === 2) return this.escapeId(values[offset - 1]);
                    else return this.escape(values[offset - 1]);
                }.bind(this),
            );
        } else {
            const escaped = query.replace(
                /\:(\w+)/g,
                function (text, key) {
                    if (values.hasOwnProperty(key)) {
                        return this.escape(values[key]);
                    }

                    return text;
                }.bind(this),
            );

            return escaped.replace(/\[(\w+)\]/g, function (text, key) {
                if (values.hasOwnProperty(key)) {
                    return this.escapeId(values[key]);
                }

                return text;
            });
        }
    }
    return con;
}

Processor.prototype.presetConnection = function (config) {
    this.host = config.host || this.host;
    this.user = config.user || this.user;
    this.password = config.password || this.password;
    if (config.database) {
        this.database = config.database
    } else {
        delete this.database;
    }
}

Processor.prototype.connectWithTbegin = function (db) {
    if (!db) {
        db = {};
    }
    return new Promise((resolve, reject) => {
        var con = mysql.createConnection({
            host: db.host || this.host,
            user: db.user || this.user,
            password: db.password || this.password,
            database: db.database || this.database
        });
        con.config.queryFormat = function (query, values) {
            if (!values) return query;

            if (Array.isArray(values)) {
                let offset = 0;

                return query.replace(
                    /(\?{1,2})/g,
                    function (text, match) {
                        offset++;

                        if (offset > values.length) return text;

                        if (match.length === 2) return this.escapeId(values[offset - 1]);
                        else return this.escape(values[offset - 1]);
                    }.bind(this),
                );
            } else {
                const escaped = query.replace(
                    /\:(\w+)/g,
                    function (text, key) {
                        if (values.hasOwnProperty(key)) {
                            return this.escape(values[key]);
                        }

                        return text;
                    }.bind(this),
                );

                return escaped.replace(/\[(\w+)\]/g, function (text, key) {
                    if (values.hasOwnProperty(key)) {
                        return this.escapeId(values[key]);
                    }

                    return text;
                });
            }
        }
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                return reject(err);
            }
            con.beginTransaction(function (err) {
                if (err) {
                    err.status = 409;
                    return reject(err);
                }
                return resolve(con);
            });
        });
    });
}

Processor.prototype.executeSmartLoop = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }
        if (params.length == 0) {
            var err = new Error('undefined parameter for smart loop');
            err._con = con;
            err.status = 409;
            return callback(err);
        }
        async.times(params.length, function (n, callback) {
            con.query(query, params[n], function (err, result) {
                if (err) {
                    err._con = con;
                    err.status = 409;
                    return callback(err);
                } else {
                    result._con = con;
                    return callback(null, result);
                }
            })
        }, function (err, result) {
            if (err) {
                reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}
Processor.prototype.executeSmartLoopWithinTransaction = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }
        if (params.length == 0) {
            var err = new Error('undefined parameter for smart loop');
            err._con = con;
            err.status = 409;
            return callback(err);
        }
        async.times(params.length, function (n, callback) {
            con.query(query, params[n], function (err, result) {
                if (err) {
                    err._con = con;
                    err.status = 409;
                    return callback(err);
                } else {
                    result._con = con;
                    return callback(null, result);
                }
            })
        }, function (err, result) {
            if (err) {
                reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.execute = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(query, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}
Processor.prototype.executeWithinTransaction = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(query, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.executeWithOptions = function (option, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(option, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}
Processor.prototype.executeWithOptionsWithinTransaction = function (option, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(option, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.rollbackAndCloseConnection = function (con) {
    return new Promise((resolve, reject) => {
        if (!con) {
            return resolve();
        }
        if (con.state != 'authenticated') {
            console.log('Already Commited');
            return resolve();
        }
        con.rollback(function (err) {
            if (err) {
                err.status = 409;
                err._con = con;
                reject(err);
            } else {
                con.destroy();
                con = null;
                resolve(null);
            }
        });
    })
}

Processor.prototype.commitAndCloseConnection = function (con) {

    return new Promise((resolve, reject) => {
        con.commit(function (err) {
            if (err) {
                err.status = 409;
                err._con = con;
                reject(err);
            } else {
                con.destroy();
                con = null;
                resolve(null);
            }
        });
    })
}
Processor.prototype.commitAndContinue = function (con) {

    return new Promise((resolve, reject) => {
        con.commit(function (err) {
            if (err) {
                err.status = 409;
                err._con = con;
                reject(err);
            } else {
                resolve(null);
            }
        });
    })
}

Processor.prototype.executeUpdatePromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                reject(err);
                return;
            }
            con.query(query, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    reject(err);
                    return;
                }
                con.destroy();
                resolve(result);
            });
        });
    });
}

Processor.prototype.executeUpdateIgnorePromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                return resolve(err);
            }
            con.query(query, params, function (err, result) {
                if (err) {
                    con.destroy();
                    return resolve(err);
                }
                con.destroy();
                return resolve(result);
            });
        });
    });
}

Processor.prototype.executeUpdateEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                err.status = 409;
                console.log(err.message);
                next(err);
                con.destroy();
                return;
            }
            if (result.affectedRows == 0) {
                var err = new Error("Nothing Updated");
                err.status = 406;
                console.log("Nothing affected");
                next(err);
                con.destroy();
                return;
            }
            params.id = result.insertId;

            res.json(result);
            con.destroy();
        });
    });
}


Processor.prototype.executeAndFetchPromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];
        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            } var options = {
                sql: query, typeCast: function (field, next) {
                    if (field.type == 'JSON') {
                        return JSON.parse(field.string());
                    }
                    if (field.type == 'TIMESTAMP') {
                        let str = field.string();
                        if (str != null)
                            return moment(str).format('YYYY-MM-DD HH:mm:ss');
                        else
                            return str;
                    }
                    return next();
                }
            };
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}

Processor.prototype.executeAndFetchWithOptionsPromise = function (query, params, options, dbConfig) {

    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}

Processor.prototype.executeAndFetchFirstPromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            var options = {
                sql: query, typeCast: function (field, next) {
                    if (field.type == 'JSON') {
                        return JSON.parse(field.string());
                    }
                    if (field.type == 'TIMESTAMP') {
                        let str = field.string();
                        if (str != null)
                            return moment(str).format('YYYY-MM-DD HH:mm:ss');
                        else
                            return str;
                    }
                    return next();
                }
            };
            con.query(options, params, function (err, result) {
                con.destroy();
                if (err) {
                    err.status = 409;
                    return reject(err);
                }
                if (result)
                    resolve(result[0]);
                else
                    resolve({});
            });
        });
    })
}

Processor.prototype.executeAndFetchFirstWithOptionsPromise = function (query, params, options, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}

Processor.prototype.executeAndFetchEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                console.log(err.message);
                err.status = 409;
                next(err);
                con.destroy();
                return;
            }
            res.json(result);
            con.destroy();
        });
    });
}

Processor.prototype.executeAndFetchFirstEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            err.status = 409;
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                console.log(err.message);
                err.status = 409;
                next(err);
                con.destroy();
                return;
            }
            if (result) {
                delete result[0].password;
                delete result[0].availability;
                res.json(result[0]);
                con.destroy();
            } else {
                var err = new Error('Not Found');
                err.status = 406;
                next(err);
                con.destroy();
                return;
            }
            con.destroy();
        });
    });
}


module.exports = new Processor();
